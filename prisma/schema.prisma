generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                String   @id @default(uuid())
  email             String   @unique
  password          String
  name              String
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  // Friends
  sentFriends     Friend[]       @relation("FriendSender")
  receivedFriends Friend[]       @relation("FriendReceiver")
  notifications   Notification[]

  // Core
  streak     Streak?
  activities Activity[]
  badges     Badge[]

  // Vocab
  userVocabProgress UserVocabProgress[]
  userVocabs        UserVocab[]

  // Presence + Study
  presence      UserPresence?
  studySessions StudySession[]
  studyEvents   StudyEvent[]

  // Chat (DM + Group)
  chatConversationMembers ChatConversationMember[]
  sentChatMessages        ChatMessage[]         @relation("ChatMessageSender")
  receivedChatMessages    ChatMessage[]         @relation("ChatMessageReceiver")
  chatMessageReactions    ChatMessageReaction[]
  chatMessageHidden       ChatMessageHidden[]

  // Settings
  settings UserSettings?
}

model Friend {
  id         String       @id @default(uuid())
  createdAt  DateTime     @default(now())
  receiverId String
  senderId   String
  status     FriendStatus @default(PENDING)
  receiver   User         @relation("FriendReceiver", fields: [receiverId], references: [id])
  sender     User         @relation("FriendSender", fields: [senderId], references: [id])

  @@unique([senderId, receiverId])
}

model Streak {
  id            String   @id @default(uuid())
  userId        String   @unique
  currentStreak Int      @default(1)
  lastStudyDate DateTime
  minutes       Int      @default(0)
  createdAt     DateTime @default(now())
  recoveryMonth Int
  recoveryUsed  Int      @default(0)
  updatedAt     DateTime @updatedAt
  user          User     @relation(fields: [userId], references: [id])
}

model Activity {
  id        String       @id @default(uuid())
  userId    String
  type      ActivityType @default(STUDY)
  minutes   Int?
  streak    Int?
  createdAt DateTime     @default(now())
  user      User         @relation(fields: [userId], references: [id])
}

model Badge {
  id        String    @id @default(uuid())
  code      BadgeCode
  name      String
  userId    String
  createdAt DateTime  @default(now())
  user      User      @relation(fields: [userId], references: [id])

  @@unique([code, userId])
}

model Notification {
  id        String    @id @default(cuid())
  userId    String
  message   String
  createdAt DateTime  @default(now())
  data      Json?
  link      String?
  readAt    DateTime?
  title     String?
  type      String    @default("GENERAL")
  user      User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, createdAt])
  @@index([userId, readAt])
}

model Lesson {
  hskLevel  Int
  vi        String
  zh        String
  pinyin    String
  createdAt DateTime @default(now())
  id        Int      @id @default(autoincrement())
}

model Vocab {
  id                Int                 @id @default(autoincrement())
  zh                String
  pinyin            String
  vi                String
  level             Int
  userVocabs        UserVocab[]
  userVocabProgress UserVocabProgress[]
}

model UserVocabProgress {
  id         Int      @id @default(autoincrement())
  userId     String
  vocabId    Int
  correct    Int      @default(0)
  wrong      Int      @default(0)
  lastSeen   DateTime @default(now())
  box        Int      @default(1)
  nextReview DateTime @default(now())
  user       User     @relation(fields: [userId], references: [id])
  vocab      Vocab    @relation(fields: [vocabId], references: [id])

  @@unique([userId, vocabId])
}

model UserVocab {
  id      Int    @id @default(autoincrement())
  userId  String
  vocabId Int
  user    User   @relation(fields: [userId], references: [id])
  vocab   Vocab  @relation(fields: [vocabId], references: [id])

  @@unique([userId, vocabId])
}

model UserPresence {
  userId     String    @id
  online     Boolean   @default(false)
  lastSeenAt DateTime?
  updatedAt  DateTime  @updatedAt
  user       User      @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model StudySession {
  id        String    @id @default(uuid())
  userId    String
  startedAt DateTime  @default(now())
  endedAt   DateTime?
  user      User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, endedAt])
}

model StudyEvent {
  id          String        @id @default(uuid())
  userId      String
  type        StudyItemType
  correct     Boolean
  durationSec Int           @default(0)
  itemId      String?
  createdAt   DateTime      @default(now())
  user        User          @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, createdAt])
  @@index([type, createdAt])
}

model ChatConversation {
  id            String               @id @default(uuid())
  type          ChatConversationType @default(DM)

  // DM legacy fields (used when type = DM)
  userAId       String?
  userBId       String?

  // Group fields (used when type = GROUP)
  title         String?
  avatar        String?
  createdById   String?

  lastMessageAt DateTime?
  createdAt     DateTime             @default(now())
  updatedAt     DateTime             @updatedAt

  members   ChatConversationMember[]
  messages  ChatMessage[]

  // DM uniqueness (multiple NULLs are allowed in Postgres)
  @@unique([userAId, userBId])
  @@index([type, lastMessageAt])
}

model ChatConversationMember {
  id             String   @id @default(uuid())
  conversationId String
  userId         String

  role       ChatMemberRole @default(MEMBER)
  nickname   String?
  joinedAt   DateTime @default(now())
  lastReadAt DateTime?

  conversation ChatConversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  user         User            @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([conversationId, userId])
  @@index([userId, lastReadAt])
}

model ChatMessage {
  id             String          @id @default(uuid())
  conversationId String
  senderId       String
  receiverId     String?         // DM: set; GROUP: null

  text        String
  type        ChatMessageType @default(TEXT)
  attachments Json?
  editedAt    DateTime?
  deletedAt   DateTime?

  // DM read receipt (kept for backward compatibility)
  isRead   Boolean  @default(false)
  readAt   DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  conversation ChatConversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  sender       User             @relation("ChatMessageSender", fields: [senderId], references: [id], onDelete: Cascade)
  receiver     User?            @relation("ChatMessageReceiver", fields: [receiverId], references: [id], onDelete: Cascade)

  reactions ChatMessageReaction[]
  hiddenBy  ChatMessageHidden[]

  @@index([conversationId, createdAt])
  @@index([receiverId, isRead])
  @@index([receiverId, readAt])
  @@index([senderId, createdAt])
}

model ChatMessageReaction {
  id        String   @id @default(uuid())
  messageId String
  userId    String
  emoji     String
  createdAt DateTime @default(now())

  message ChatMessage @relation(fields: [messageId], references: [id], onDelete: Cascade)
  user    User        @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([messageId, userId, emoji])
  @@index([messageId, createdAt])
  @@index([userId, createdAt])
}

model ChatMessageHidden {
  id        String   @id @default(uuid())
  userId    String
  messageId String
  createdAt DateTime @default(now())

  user    User        @relation(fields: [userId], references: [id], onDelete: Cascade)
  message ChatMessage @relation(fields: [messageId], references: [id], onDelete: Cascade)

  @@unique([userId, messageId])
  @@index([userId, createdAt])
}


model UserSettings {
  userId                String   @id
  createdAt             DateTime @default(now())
  updatedAt             DateTime @updatedAt
  onlyTingWhenNotOnChat Boolean  @default(true)
  soundEnabled          Boolean  @default(true)
  theme                 String   @default("light")
  user                  User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

enum FriendStatus {
  PENDING
  ACCEPTED
  BLOCKED
}

enum ActivityType {
  STUDY
}

enum BadgeCode {
  STREAK_3
  STREAK_7
  STREAK_30
  MINUTES_60
  NO_RECOVERY_7
}

enum StudyItemType {
  VOCAB
  SENTENCE
}


enum ChatConversationType {
  DM
  GROUP
}

enum ChatMemberRole {
  OWNER
  ADMIN
  MEMBER
}

enum ChatMessageType {
  TEXT
  IMAGE
  FILE
  STICKER
}
